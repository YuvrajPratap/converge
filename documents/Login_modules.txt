The focus of the tutorial will be on how we can generate JWTs on the Laravel side, obtain them on the front-end and then send them along with every request to the API.
We’ll be using a couple open source packages for this application: jwt-auth for creating JWTs on the Laravel side and Satellizer for handling the AngularJS authentication logic.

		laravel new jot-bot
		php artisan key:generate
		cd jot-bot
		php artisan serve

If everything is working you should see the Laravel welcome page.

Now that the core Laravel files are installed, let’s install jwt-auth. Open composer.json and update the require object to include jwt-auth:

		// composer.json
		"require": {
		       "php": ">=5.5.9",
		       "laravel/framework": "5.1.*",
		       "tymon/jwt-auth": "0.5.*"
		   },
   
Next, let’s bring this package in by running an update. From the command line:

		composer update

We’ll now need to update the providers array in config/app.php with the jwt-auth provider. Open up config/app.php, find the providers array located on line 111 and add this to it:

		Tymon\JWTAuth\Providers\JWTAuthServiceProvider::class

We should also add in the jwt-auth facades which we can do in config/app.php. Find the aliases array and add these facades to it:

		'JWTAuth'   => Tymon\JWTAuth\Facades\JWTAuth::class,
		'JWTFactory' => Tymon\JWTAuth\Facades\JWTFactory::class


We also need to publish the assets for this package. From the command line:

		php artisan vendor:publish --provider="Tymon\JWTAuth\Providers\JWTAuthServiceProvider"

After you run this command you will see a new file in the config folder called jwt.php. This file contains settings for jwt-auth, one of which we need to change right away. We need to generate a secret key which we can do from the command line:

		php artisan jwt:generate

We’ve got everything installed on the Laravel side—now let’s take care of the AngularJS dependencies.

There are a number of things that need to happen on the front-end so that we can send a JWT with every request to the Laravel API after our user is authenticated. Namely, we need to keep the JWT in local storage once we retrieve it from the API and also need to add a header to every subsequent request that contains the token. We could write the appropriate JavaScript to accomplish this on our own, but a package has already been created that does a great job of it. Instead of spending extra effort, let’s make use of Satellizer.

Let’s use npm to install our front-end dependencies. From the command line:

		cd public
		sudo chmod 777 -R /home/yuvraj/tmp
		npm install angular satellizer angular-ui-router bootstrap

Creating Some Test Data

Laravel comes with a migration for a users table out of the box and this is the only one we’ll need for the tutorial. Let’s run the migrations so that this table gets created in the database and then seed it with some test data. From the command line:

		php artisan migrate

For seeding, we’ll put the array of users and the logic to insert them into the database right within DatabaseSeeder.php, but you can also create a separate seeder file and call it from that file if you like.

		// database/seeds/DatabaseSeeder.php
		<?php
		use Illuminate\Database\Seeder;
		use Illuminate\Database\Eloquent\Model;
		use App\User;
		class DatabaseSeeder extends Seeder
		{
		    public function run()
		    {
		        Model::unguard();
		        DB::table('users')->delete();
		        $users = array(
		                ['name' => 'Ryan Chenkie', 'email' => 'ryanchenkie@gmail.com', 'password' => Hash::make('secret')],
		                ['name' => 'Chris Sevilleja', 'email' => 'chris@scotch.io', 'password' => Hash::make('secret')],
		                ['name' => 'Holly Lloyd', 'email' => 'holly@scotch.io', 'password' => Hash::make('secret')],
		                ['name' => 'Adnan Kukic', 'email' => 'adnan@scotch.io', 'password' => Hash::make('secret')],
		        );
		        // Loop through each user above and create the record for them in the database
		        foreach ($users as $user)
		        {
		            User::create($user);
		        }
		        Model::reguard();
		    }
		}

In this seeder we are creating an array of users and then looping through them to add them to the database. This file relies on us using App\User which is the User model that also ships with Laravel. As we loop through the users we call create on each to add that record to the database. With this in place, we just need to run the seeder.

		php artisan db:seed

To generate a new seeder type :

		php artisan make:seeder UsersTableSeeder

A seeder class only contains one method by default: run. This method is called when the db:seed Artisan command is executed.

Within the DatabaseSeeder class, you may use the call method to execute additional seed classes. Using the call method allows you to break up your database seeding into multiple files so that no single seeder class becomes overwhelmingly large. Simply pass the name of the seeder class you wish to run:

		/**
		 * Run the database seeds.
		 *
		 * @return void
		 */
		public function run()
		{
		    Model::unguard();

		    $this->call(UsersTableSeeder::class);
		    $this->call(PostsTableSeeder::class);
		    $this->call(CommentsTableSeeder::class);

		    Model::reguard();
		}

By default, the db:seed command runs the DatabaseSeeder class, which may be used to call other seed classes. However, you may use the --class option to specify a specific seeder class to run individually:

		php artisan db:seed

		php artisan db:seed --class=UsersTableSeeder

You may also seed your database using the migrate:refresh command, which will also rollback and re-run all of your migrations. This command is useful for completely re-building your database:

		php artisan migrate:refresh --seed

Now we have to create the API Routes
Once we’ve confirmed that the database has been seeded properly, let’s get the API setup in routes.php.

		// app/Http/routes.php
		<?php
		Route::get('/', function () {
		    return view('index');
		});
		Route::group(['prefix' => 'api'], function()
		{
		    Route::resource('authenticate', 'AuthenticateController', ['only' => ['index']]);
		    Route::post('authenticate', 'AuthenticateController@authenticate');
		});

We’ve done a couple things here—first, we’ve changed the starting route to load a view that we’ll create later called index instead of welcome. Next, we’ve created a route group that is prefixed with api and that currently serves a resource called authenticate. We only really want the index method of this resource controller which we indicate with the third argument. We’ll also need a custom method called authenticate on this controller which handles generating and returning a JWT.

Now we need to create a resource controller called AuthenticateController. From the command line:

		php artisan make:controller AuthenticateController

If that runs successfully you should now see AuthenticateController.php in app/Http/Controllers.
We’re going to need to use some pieces of the JWTAuth package in this controller.

		<?php
		namespace App\Http\Controllers;
		use Illuminate\Http\Request;
		use App\Http\Requests;
		use App\Http\Controllers\Controller;
		use JWTAuth;
		use Tymon\JWTAuth\Exceptions\JWTException;
		class AuthenticateController extends Controller
		{
		    public function index()
		    {
		        // TODO: show users
		    }    
		    public function authenticate(Request $request)
		    {
		        $credentials = $request->only('email', 'password');
		        try {
		            // verify the credentials and create a token for the user
		            if (! $token = JWTAuth::attempt($credentials)) {
		                return response()->json(['error' => 'invalid_credentials'], 401);
		            }
		        } catch (JWTException $e) {
		            // something went wrong
		            return response()->json(['error' => 'could_not_create_token'], 500);
		        }
		        // if no errors are encountered we can return a JWT
		        return response()->json(compact('token'));
		    }
		}

The try block in the authenticate method attempts to produce a token using the JWTAuth facade with the user’s credentials. If something goes wrong with that, the method will return a 401 and say the credentials are invalid. In other cases where an exception is thrown, it will return a 500 indicating an internal server error and saying that something went wrong. If we are able to get past that then we can return a token. Returning it with compact('token') puts the object on a key called token which will come in handy when we read it with Satellizer.

We’ll use this controller to show data for all users as well, but let’s first test out the API.

By default, Laravel has CSRF token verification turned on, but since we’re using JWTs in a stateless manner now, we don’t really need CSRF tokens. We can turn this default behavior off by commenting out the VerifyCsrfToken middleware in Kernel.php.

We’re also eventually going to need to use the middleware that jwt-auth provides. We can set that up in the routeMiddleware array in Kernel.php as well.

		// app/Http/Kernel.php
		...
		namespace App\Http;

		use Illuminate\Foundation\Http\Kernel as HttpKernel;

		class Kernel extends HttpKernel
		{

		    protected $middleware = [
		        \Illuminate\Foundation\Http\Middleware\CheckForMaintenanceMode::class,
		        \App\Http\Middleware\EncryptCookies::class,
		        \Illuminate\Cookie\Middleware\AddQueuedCookiesToResponse::class,
		        \Illuminate\Session\Middleware\StartSession::class,
		        \Illuminate\View\Middleware\ShareErrorsFromSession::class,
		        // \App\Http\Middleware\VerifyCsrfToken::class,
		    ];

		    protected $routeMiddleware = [
		        'auth' => \App\Http\Middleware\Authenticate::class,
		        'auth.basic' => \Illuminate\Auth\Middleware\AuthenticateWithBasicAuth::class,
		        'guest' => \App\Http\Middleware\RedirectIfAuthenticated::class,
		        'jwt.auth' => \Tymon\JWTAuth\Middleware\GetUserFromToken::class,
		        'jwt.refresh' => \Tymon\JWTAuth\Middleware\RefreshToken::class
		    ];
		}

Now that VerifyCsrfToken is turned off, let’s check the API with Postman.

If we send a POST request to localhost:8000/api/authenticate with the credentials for one of our users as URL parameters, we can see that we get a token returned.

We’re going to return the data for all of the users in the database, but only if there is a token passed along with the request. We can make this happen by protecting our API with the middleware that comes with jwt-auth.

Let’s add some logic to show all of the users if the token sent along with the request is valid.

		// app/Http/Controllers/AuthenticateController.php
		class AuthenticateController extends Controller
		{
			public function __construct()
			   {
			       // Apply the jwt.auth middleware to all methods in this controller
			       // except for the authenticate method. We don't want to prevent
			       // the user from retrieving their token if they don't already have it
			       $this->middleware('jwt.auth', ['except' => ['authenticate']]);
			   }

			public function index()
			{
			    // Retrieve all the users in the database and return them
			    $users = User::all();
			    return $users;
			}
			...

Here we are saying we want the jwt-auth middleware to be applied to everything in the controller except the authenticate method (we don’t want to block the user from retrieving their token) and we have the index method returning a list of all users.

If we try making a GET request to localhost:8000/api/authenticate without a JWT in as a header or URL parameter, we get a 400 error that says no token was provided.

The jwt-auth middleware checks for the presence of the token and let’s the request through if it is there and is valid, but rejects the request if it is not.

Just to prove that the middleware is doing its job, let’s try removing a character from the token to invalidate it. We can see that the call we then make to the index method gets denied and we can’t see the users list.

Setting up The Front-End

Now that the API is setup and the middleware is functioning properly we can create the front-end of our app.

We’ll need to setup our initial view in an index.php file because this is what our Laravel routes.php file is setup to return when the user hits the main / route.

		<!-- resources/views/index.php -->
		<!doctype html>
		<html>
		    <head>
		        <meta charset="utf-8">
		        <title>Angular-Laravel Authentication</title>
		        <link rel="stylesheet" href="node_modules/bootstrap/dist/css/bootstrap.css">
		    </head>
		    <body ng-app="authApp">
		        <div class="container">
		            <div ui-view></div>
		        </div>        
		    </body>
		    <!-- Application Dependencies -->
		    <script src="node_modules/angular/angular.js"></script>
		    <script src="node_modules/angular-ui-router/build/angular-ui-router.js"></script>
		    <script src="node_modules/satellizer/satellizer.js"></script>

		    <!-- Application Scripts -->
		    <script src="scripts/app.js"></script>
		    <script src="scripts/authController.js"></script>
		    <script src="scripts/userController.js"></script>
		</html>

In the index.php file we have included all of the application dependency scripts that we installed earlier and have also put references in for the application scripts that we’ve yet to create. Since we’re using UI Router we are serving a ui-view in the middle of the page which is what will be used to handle our different states.

Next, let’s create our main app.js file.

		// public/scripts/app.js

		(function() {

		    'use strict';

		    angular
		        .module('authApp', ['ui.router', 'satellizer'])
		        .config(function($stateProvider, $urlRouterProvider, $authProvider) {

		            // Satellizer configuration that specifies which API
		            // route the JWT should be retrieved from
		            $authProvider.loginUrl = '/api/authenticate';

		            // Redirect to the auth state if any other states
		            // are requested other than users
		            $urlRouterProvider.otherwise('/auth');
		            
		            $stateProvider
		                .state('auth', {
		                    url: '/auth',
		                    templateUrl: '../views/authView.html',
		                    controller: 'AuthController as auth'
		                })
		                .state('users', {
		                    url: '/users',
		                    templateUrl: '../views/userView.html',
		                    controller: 'UserController as user'
		                });
		        });
		})();

Here we are loading the ui.router and satellizer modules and setting up some configuration for them. Satellizer gives us an $authProvider which can be used to configure its settings. In particular, we want to specify that when using Satellizer to login, the HTTP requests that get made to retrieve the JWT from the API should go to api/authenticate.

We also use $stateProvider to setup configuration for the two states that we’ll be using: auth and users.

We’ll now need to create views for the auth and users states and controllers to handle their behavior.

		// public/scripts/authController.js
		(function() {
		    'use strict';
		    angular
		        .module('authApp')
		        .controller('AuthController', AuthController);
		    function AuthController($auth, $state) {
		        var vm = this;
		        vm.login = function() {
		            var credentials = {
		                email: vm.email,
		                password: vm.password
		            }
		            // Use Satellizer's $auth service to login
		            $auth.login(credentials).then(function(data) {

		                // If login is successful, redirect to the users state
		                $state.go('users', {});
		            });
		        }
		    }
		})();

In our AuthController we are injecting $auth which is a service provided by Satellizer for communicating with the API and also $state so that we can handle redirects.

We’ve got one method in this controller—login—which is responsible for using the $auth service to make a call to the API to retrieve the user’s JWT. We setup our credentials object to contain an email address and password which we’ll get from the form fields in the view and then pass them to the login method on the $auth service. If the token is successfully retrieved we are redirected to the users state.

Now let’s setup the template for the login page.

		<!-- public/views/authView.html -->
		<div class="col-sm-4 col-sm-offset-4">
		    <div class="well">
		        <h3>Login</h3>
		        <form>
		            <div class="form-group">
		                <input type="email" class="form-control" placeholder="Email" ng-model="auth.email">
		            </div>
		            <div class="form-group">
		                <input type="password" class="form-control" placeholder="Password" ng-model="auth.password">
		            </div>
		            <button class="btn btn-primary" ng-click="auth.login()">Submit</button>
		        </form>
		    </div>
		</div>

In this view we setup two form fields—one for the user’s email address and the other for their password. Next we call the login method in our AuthController to submit the data.

If everything worked out we should now see the token saved in local storage.

We will also have been redirected to the users state which is what we want; however, we don’t yet have a view or controller setup to handle this state. Let’s put that in now.

		// public/scripts/userController.js
		(function() {
		    'use strict';
		    angular
		        .module('authApp')
		        .controller('UserController', UserController);  
		    function UserController($http) {
		        var vm = this;
		        vm.users;
		        vm.error;
		        vm.getUsers = function() {
		            // This request will hit the index method in the AuthenticateController
		            // on the Laravel side and will return the list of users
		            $http.get('api/authenticate').success(function(users) {
		                vm.users = users;
		            }).error(function(error) {
		                vm.error = error;
		            });
		        }
		    }
		})();

This controller has one method, getUsers, which makes an $http.get request to the API to fetch the data for all users. If the call is successful, the users data is placed on the vm.users key. If not, the error message that gets returned is placed on the vm.error key. Now let’s reflect this data in a view:

		<!-- public/views/userView.html -->
		<div class="col-sm-6 col-sm-offset-3">
		    <div class="well">
		        <h3>Users</h3>  
		        <button class="btn btn-primary" style="margin-bottom: 10px" ng-click="user.getUsers()">Get Users!</button>
		        <ul class="list-group" ng-if="user.users">
		            <li class="list-group-item" ng-repeat="user in user.users">
		                <h4>{{user.name}}</h4>
		                <h5>{{user.email}}</h5>
		            </li>
		        </ul>
		        <div class="alert alert-danger" ng-if="user.error">
		            <strong>There was an error: </strong> {{user.error.error}}
		            <br>Please go back and login again
		        </div>
		    </div>
		</div>

When this state is first loaded there won’t be any data displayed because we have set it up so that the data is fetched when the Get Users! button is clicked. Since we have our token saved in local storage, we should be able to get a list of the users back when we click this button.




Adding the Authenticated User Route

The first thing we’ll need to do is add a new method to our AuthenticateController on the Laravel side so that we can have an object of the currently authenticated user’s data returned to us. Where exactly you put this method, whether it be in an existing controller or an entirely new one, is up to you. For the sake of simplicity, we’ll stick with our current controller.

		// app/Http/Controllers/AuthenticateController.php

		...

		public function getAuthenticatedUser()
		    {
		        try {

		            if (! $user = JWTAuth::parseToken()->authenticate()) {
		                return response()->json(['user_not_found'], 404);
		            }

		        } catch (Tymon\JWTAuth\Exceptions\TokenExpiredException $e) {

		            return response()->json(['token_expired'], $e->getStatusCode());

		        } catch (Tymon\JWTAuth\Exceptions\TokenInvalidException $e) {

		            return response()->json(['token_invalid'], $e->getStatusCode());

		        } catch (Tymon\JWTAuth\Exceptions\JWTException $e) {

		            return response()->json(['token_absent'], $e->getStatusCode());

		        }

		        // the token is valid and we have found the user via the sub claim
		        return response()->json(compact('user'));
		    }

		...

The getAuthenticatedUser method grabs the JWT that will be passed along in the header of a request for the authenticated user. As we’ll see later on, when we hit the route that calls this method, we will need to have already generated a token for our user. You’ll remember from the first part of the tutorial that generating a token relies on the authenticate method within the same controller.

With the JWT passed along with the request, this method is going to use the JWTAuth facade to attempt to parse the token and authenticate the user based on it. If the credentials don’t match what is in the database, a 404 will be returned along with a message that the user wasn’t found.

If authentication was successful, we move onto some more checks using the exception handler that jwt-auth provides, and respond appropriately to each condition. If everything checks out, we return the user that the token belongs to.

You might be wondering how exactly jwt-auth knows which user to authenticate. The answer is that there is a “sub” claim included with the token payload that corresponds to the id of the user it belongs to. We can inspect this with the awesome JWT debugger provided by Auth0.

We’ll also need to add a new route to handle this method in routes.php.

		// app/Http/routes.php

		...

		Route::group(['prefix' => 'api'], function()
		{
		    Route::resource('authenticate', 'AuthenticateController', ['only' => ['index']]);
		    Route::post('authenticate', 'AuthenticateController@authenticate');
		    Route::get('authenticate/user', 'AuthenticateController@getAuthenticatedUser');
		});

		...

We specify that we want a new route at authenticate/user that responds to a GET request and uses the getAuthenticatedUser method on the AuthenticateController.

Now that we have the route and controller method in place, we should be able to get our user data returned. Let’s test it out using Postman.

Note: You might need to generate a new token if it’s been some time since you generated the last one.

Sending a GET request to the authenticate/user route of our API with the JWT as a URL parameter let’s us successfully retrieve the user data.

Now that we have our API successfully returning the user data, we’ll need to setup our authentication controller on the front-end to make a request for the data. As you’ll remember from the first part, the vm.login method on our AuthController uses Satellizer to make a request to the API for the JWT and then saves it in local storage so it can be sent along with subsequent requests. While we could make a request for the newly authenticated user’s data at various times and places in the application, it makes most sense to do so right after we know the Satellizer request for the token was successful. To accomplish this, let’s use $http to make a GET request for the user data in the then block of the initial request.

		// public/scripts/authController.js

		(function() {

		    'use strict';

		    angular
		        .module('authApp')
		        .controller('AuthController', AuthController);


		    function AuthController($auth, $state, $http, $rootScope) {

		        var vm = this;

		        vm.loginError = false;
		        vm.loginErrorText;

		        vm.login = function() {

		            var credentials = {
		                email: vm.email,
		                password: vm.password
		            }

		            $auth.login(credentials).then(function() {

		                // Return an $http request for the now authenticated
		                // user so that we can flatten the promise chain
		                return $http.get('api/authenticate/user');

		            // Handle errors
		            }, function(error) {
		                vm.loginError = true;
		                vm.loginErrorText = error.data.error;

		            // Because we returned the $http.get request in the $auth.login
		            // promise, we can chain the next promise to the end here
		            }).then(function(response) {

		                // Stringify the returned data to prepare it
		                // to go into local storage
		                var user = JSON.stringify(response.data.user);

		                // Set the stringified user data into local storage
		                localStorage.setItem('user', user);

		                // The user's authenticated state gets flipped to
		                // true so we can now show parts of the UI that rely
		                // on the user being logged in
		                $rootScope.authenticated = true;

		                // Putting the user's data on $rootScope allows
		                // us to access it anywhere across the app
		                $rootScope.currentUser = response.data.user;

		                // Everything worked out so we can now redirect to
		                // the users state to view the data
		                $state.go('users');
		            });
		        }
		    }

		})();

You’ll see here that we are now returning the $http.get request in the success handler of the $auth.login request. While we could take care of the whole $http.get request directly in this success handler, if we instead return it then we can tack another then onto the end of the $auth.login request which helps to flatten the promise chain. Since we are just dealing with two promises here, it wouldn’t be all that bad if we nested them, but in case we ever needed more, this approach helps to keep things cleaner as nesting a lot of promises can start to get messy.

In the then block of the request for our user data we are grabbing the response and saving it into local storage. Note that we need to call JSON.stringify on the returned object because local storage items need to be saved as text.

Next, we’re putting an authenticated property on $rootScope which is a boolean to let us know that the user has logged in. This is for convenience sake, as we’ll now be able to use this $rootScope property to conditionally show or hide elements in the view. Likewise, we are saving the user data on $rootScope to conveniently access it across the app. Whether or not you use $rootScope in this fashion is your call—some prefer not to use it in this manner.

Finally, we are redirecting the user to the users state like we were before.
Displaying the User’s Name in the View

Now that we have the authenticated user’s data on $rootScope to work with, let’s have their name be displayed in the view.

		<!-- public/views/userView.html -->

		<div class="col-sm-6 col-sm-offset-3">
		    <div class="well">
		        <h5 ng-if="authenticated">Welcome, {{currentUser.name}}</h5>
		        <h3>Users</h3>
		        <div class="buttons" style="margin-bottom: 10px">
		            <button class="btn btn-primary" ng-click="user.getUsers()">Get Users!</button>
		            <button class="btn btn-danger" ng-click="user.logout()">Logout</button>
		        </div>
		        <ul class="list-group" ng-if="user.users">
		            <li class="list-group-item" ng-repeat="user in user.users">
		                <h4>{{user.name}}</h4>
		                <h5>{{user.email}}</h5>
		            </li>
		        </ul>
		        <div class="alert alert-danger" ng-if="user.error">
		            <strong>There was an error: </strong> {{user.error.error}}
		            <br>Please go back and login again
		        </div>
		    </div>
		</div>

You’ll see here that we’ve added an h5 tag to the view that gets included in the DOM if $rootScope.authenticated is true. Also on $rootScope is the currentUser object from which we want the name property for the welcome message.

Now when we are at the users state we will see the authenticated user’s name displayed.

You’ll probably have noticed above that we’ve added another button to the users view which is meant to log the user out. Its ng-click is pointing to a logout method on UserController which we’ll create now.

Note: Normally we would want to have all methods dealing with authentication such as login and logout in the same spot. The ideal would be to extract their functionality into a service. For this quick example, we’ll put the logout method right into the UserController so that we have access to it from the view in our current setup.

		// public/scripts/userController.js

		(function() {

		    'use strict';

		    angular
		        .module('authApp')
		        .controller('UserController', UserController);

		    function UserController($http, $auth, $rootScope) {

		        var vm = this;

		        vm.users;
		        vm.error;

		        vm.getUsers = function() {

		            //Grab the list of users from the API
		            $http.get('api/authenticate').success(function(users) {
		                vm.users = users;
		            }).error(function(error) {
		                vm.error = error;
		            });
		        }

		        // We would normally put the logout method in the same
		        // spot as the login method, ideally extracted out into
		        // a service. For this simpler example we'll leave it here
		        vm.logout = function() {

		            $auth.logout().then(function() {

		                // Remove the authenticated user from local storage
		                localStorage.removeItem('user');

		                // Flip authenticated to false so that we no longer
		                // show UI elements dependant on the user being logged in
		                $rootScope.authenticated = false;

		                // Remove the current user info from rootscope
		                $rootScope.currentUser = null;
		            });
		        }
		    }

		})();

The logout method is going to make use of the $auth service provided by Satellizer, much like the login method. In the $auth.logout success handler we remove the user item from local storage and set $rootScope.authenticated to false. We also want to remove the user data from $rootScope as well.

The Satellizer $auth.logout method will remove the satellizer_token from local storage as well. Let’s try logging out to confirm everything is working.

You’ll notice that we were redirected to the auth state when we logged out. Satellizer handles redirects for us when we use the $auth.logout and the default is to take us to the main / route. Since our app.js file uses $urlRouterProvider to specify we want to go to the auth route/state anytime a state other than users is requested, that’s where we’re sent.
A Note About JWT’s and Logging Out

Now that the user is logged out, further requests to the API will not work because we no longer have a JWT in local storage to be sent along with requests. However, the token is still valid on the Laravel side and could theoretically be used by someone else if they somehow got access to it. There’s no effective way to invalidate the JWT, but we can increase our protection by giving all JWT’s a short lifespan. The time to live for JWTs defaults to one hour and can be adjusted in the jwt-auth configuration.

		// config/jwt.php

		...

		    /*
		    |--------------------------------------------------------------------------
		    | JWT time to live
		    |--------------------------------------------------------------------------
		    |
		    | Specify the length of time (in minutes) that the token will be valid for.
		    | Defaults to 1 hour
		    |
		    */

		   'ttl' => 60,

		...

Redirecting the User When Logged Out

The $auth.logout method we put in above does a fine job of redirecting us to the auth state when we request to be logged out, but as it stands we could still reach the users state even though we’re not authenticated. We won’t be able to see any data because—as we saw in the first part of the tutorial—we get an error message returned by the API when we don’t have a JWT to send. Although our API and data are protected, we really should prevent the user from reaching any state other than auth if they aren’t actually authenticated. We should also redirect the user to the auth state once an API error related to a missing or invalid token is encountered. An example of where this would be useful is if the user leaves their browser open and is away from their computer for more than an hour. After returning they won’t be able to use the application because their token will be invalid.

Angular’s $http service gives us the ability to catch HTTP requests from anywhere in the app by using interceptors. Like the AngularJS docs say, interceptors are useful for pre-processing requests or post-processing responses. In our case, we’re going to want to post-process responses, and specifically, those responses that indicate that we have a missing or invalid token.

To make use of interceptors we need to set one up in the config block of app.js and then push it onto the $httpProvider.interceptors array.

		// public/scripts/app.js

		(function() {

		    'use strict';

		    angular
		        .module('authApp', ['ui.router', 'satellizer'])
		        .config(function($stateProvider, $urlRouterProvider, $authProvider, $httpProvider, $provide) {

            function redirectWhenLoggedOut($q, $injector) {

                return {

                    responseError: function(rejection) {

                        // Need to use $injector.get to bring in $state or else we get
                        // a circular dependency error
                        var $state = $injector.get('$state');

                        // Instead of checking for a status code of 400 which might be used
                        // for other reasons in Laravel, we check for the specific rejection
                        // reasons to tell us if we need to redirect to the login state
                        var rejectionReasons = ['token_not_provided', 'token_expired', 'token_absent', 'token_invalid'];

                        // Loop through each rejection reason and redirect to the login
                        // state if one is encountered
                        angular.forEach(rejectionReasons, function(value, key) {

                            if(rejection.data.error === value) {

                                // If we get a rejection corresponding to one of the reasons
                                // in our array, we know we need to authenticate the user so 
                                // we can remove the current user from local storage
                                localStorage.removeItem('user');

                                // Send the user to the auth state so they can login
                                $state.go('auth');
                            }
                        });

                        return $q.reject(rejection);
                    }
                }
            }

            // Setup for the $httpInterceptor
            $provide.factory('redirectWhenLoggedOut', redirectWhenLoggedOut);

            // Push the new factory onto the $http interceptor array
            $httpProvider.interceptors.push('redirectWhenLoggedOut');

            $authProvider.loginUrl = '/api/authenticate';

		...

We’re injecting some new dependencies into the config block—$httpProvider and $provider. The first thing we do is setup a new function called redirectWhenLoggedOut that will contain the logic of what to do when certain response messages are encountered. The $http.interceptors array is going to need an object with some specific keys on it to work. In our case we only need to worry about response errors so we specify a key called responseErrors on an object that is returned from this function.

We’re going to need to make use of the $state service to do redirection, but as you’ll see, we’re bringing it in somewhat differently. If we were to inject it in the traditional way—between the parentheses in the function definition—we’ll get a “circular dependency error”. Instead, we can use $injector.get to inject it in and put it on a variable called $state which we can then use to call the actual methods of the $state service.

The anonymous function on the responseError key has a rejection parameter which we can use to grab the data and status associated with the response. As you might have seen in the console when we’ve made requests without a valid JWT, a 400 bad request is what gets returned. If we wanted to keep things simple, we could listen for all 400 status codes and redirect to the login page when they are encountered. However, there may be other reasons that a 400 error gets returned from the API that we don’t know about. To play it safe and to be very specific to the jwt-auth exceptions, we can also respond the specific status messages that are returned. To handle this, we create an array of rejectionReasons that we’ll loop through.

Using angular.forEach, we loop through each of the rejectionReasons and if the rejection error is equal to one of them, we remove the user data from local storage and redirect to the auth state.

The $provide.factory let’s us specify the name of the interceptor we want to create and the second argument references the function above that we use to handle the logic for it. We then push this on the $http.interceptors array.
Initializing the User When the App Loads

So far the way our app handles setting the user state and data on the front-end is rather specific. We set $rootScope.authenticated to true and $rootScope.currentUser to the user’s data when the login screen is followed, but what happens if the user doesn’t arrive to the app via the auth state? If their JWT is expired or otherwise invalid then they will need to go to the login screen anyway, but if they still have a valid token when coming back to the app after navigating away or closing the screen, these properties on $rootScope that we’re using in the view won’t be set.

To fix this we can write some logic that will check whether there is a user key set in local storage and if there is, set the $rootScope properties mentioned above appropriately. To do so, we’ll make use of Angular’s $on event listener with the$stateChangeStart event provided by UI Router. We’ll put this all within the run block in app.js.

		// public/scripts/app.js

		...

		.run(function($rootScope, $state) {

            // $stateChangeStart is fired whenever the state changes. We can use some parameters
            // such as toState to hook into details about the state as it is changing
            $rootScope.$on('$stateChangeStart', function(event, toState) {

                // Grab the user from local storage and parse it to an object
                var user = JSON.parse(localStorage.getItem('user'));            

                // If there is any user data in local storage then the user is quite
                // likely authenticated. If their token is expired, or if they are
                // otherwise not actually authenticated, they will be redirected to
                // the auth state because of the rejected request anyway
                if(user) {

                    // The user's authenticated state gets flipped to
                    // true so we can now show parts of the UI that rely
                    // on the user being logged in
                    $rootScope.authenticated = true;

                    // Putting the user's data on $rootScope allows
                    // us to access it anywhere across the app. Here
                    // we are grabbing what is in local storage
                    $rootScope.currentUser = user;

                    // If the user is logged in and we hit the auth route we don't need
                    // to stay there and can send the user to the main state
                    if(toState.name === "auth") {

                        // Preventing the default behavior allows us to use $state.go
                        // to change states
                        event.preventDefault();

                        // go to the "main" state which in our case is users
                        $state.go('users');
                    }       
                }
            });
        });

		...

We’re using the $stateChangeStart event to listen for changes to the state the application is at. The event is fired anytime we move from one state to another and will be fired when we load the application for the first time as well. In the callback we look for a user key in local storage and use JSON.parse to turn it from a string into an object. If we have a user key then we go ahead and set $rootScope.authenticated to true and also set $rootScope.currentUser to the user data object kept in local storage.

We know that if the user is authenticated then they don’t need to see the auth state. If they end up there somehow we should really be redirecting them somewhere else and in this case we’ll consider that somewhere else to be the users state. We can access the name of the state that we’re currently on with toState.name and here we check to see if it is equal to auth. If it is, we need to redirect to the users state with $state.go. The event’s default behavior will prevent us from changing states so we need to prevent the default behavior for it to work.

With this logic setup in the $stateChangeStart event callback, we’ll now be able to have our front-end user state maintained even if the user navigates away or closes the page. You’ll notice that we’re relying on the user data in local storage as an indicator that the user is authenticated but that this wouldn’t necessarily mean their token is valid. We could write logic within the event callback to make an $http request to the server to check the validity of the user’s token, but this would create a lot of unnecessary requests. If the user’s token is invalid they will receive an error the next time they try to move forward in the application and since these errors are picked up by the $http.interceptor, the user will be redirected to the auth state on their next move anyway.